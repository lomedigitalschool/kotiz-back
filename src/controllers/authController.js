const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { User } = require('../models');
const { Op } = require('sequelize');
const smsService = require('../services/smsService');

// G√©n√©ration d'un token JWT
function generateToken(user) {
  return jwt.sign(
    { id: user.id, role: user.role },
    process.env.JWT_SECRET || "jwt-secret-kotiz",
    { expiresIn: '7d' }
  );
}

// ====================
// üìù INSCRIPTION √âTAPE 1 - ENVOYER OTP
// ====================
exports.sendRegistrationOTP = async (req, res) => {
  try {
    const { phone } = req.body;

    if (!phone) {
      return res.status(400).json({ error: "Num√©ro de t√©l√©phone requis" });
    }

    // V√©rifier si le t√©l√©phone n'est pas d√©j√† utilis√©
    const existingUser = await User.findOne({ where: { phone } });
    if (existingUser) {
      return res.status(400).json({ error: "Ce num√©ro de t√©l√©phone est d√©j√† utilis√©" });
    }

    // üîß POINT D'INT√âGRATION SMS - ENVOYER OTP D'INSCRIPTION
    console.log('üì± Envoi OTP d\'inscription pour:', phone);
    const otpResult = await smsService.sendOTP(phone, 'registration');

    if (!otpResult.success) {
      return res.status(500).json({
        error: "Erreur lors de l'envoi du code de v√©rification",
        details: otpResult.error
      });
    }

    res.json({
      success: true,
      message: "Code de v√©rification envoy√© par SMS",
      phoneNumber: phone,
      expiresIn: otpResult.expiresIn
    });

  } catch (err) {
    console.error('‚ùå Erreur lors de l\'envoi OTP inscription:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üìù INSCRIPTION √âTAPE 2 - V√âRIFIER OTP ET CR√âER COMPTE
// ====================
exports.register = async (req, res) => {
  try {
    const { name, email, phone, password, otpCode } = req.body;

    // Validation des champs requis (email ou t√©l√©phone requis)
    if (!name || !password) {
      return res.status(400).json({
        error: "Nom et mot de passe requis"
      });
    }

    // Au moins un email ou t√©l√©phone requis
    if (!email && !phone) {
      return res.status(400).json({
        error: "Email ou num√©ro de t√©l√©phone requis"
      });
    }

    // üîß POINT D'INT√âGRATION SMS - V√âRIFIER OTP (TEMPORAIREMENT D√âSACTIV√â)
    // console.log('‚úÖ V√©rification OTP d\'inscription pour:', phone);
    // const otpVerification = await smsService.verifyOTP(phone, otpCode, 'registration');

    // if (!otpVerification.success) {
    //   return res.status(400).json({
    //     error: otpVerification.error,
    //     code: otpVerification.code,
    //     attemptsLeft: otpVerification.attemptsLeft
    //   });
    // }

    // V√©rifier si email ou t√©l√©phone d√©j√† utilis√© (double v√©rification)
    const existingUser = await User.findOne({
      where: {
        [Op.or]: [
          email ? { email } : null,
          { phone }
        ].filter(Boolean)
      }
    });

    if (existingUser) {
      return res.status(400).json({ error: "Email ou t√©l√©phone d√©j√† utilis√©" });
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // Cr√©er l'utilisateur avec t√©l√©phone v√©rifi√©
    const user = await User.create({
      name,
      email: email || null,
      phone,
      passwordHash: hashedPassword,
      role: 'user',
      isPhoneVerified: true, // Marquer le t√©l√©phone comme v√©rifi√©
      phoneVerifiedAt: new Date()
    });

    // G√©n√©rer un token JWT
    const token = generateToken(user);

    console.log('‚úÖ Utilisateur cr√©√© avec succ√®s:', user.id);

    res.status(201).json({
      success: true,
      message: "Compte cr√©√© avec succ√®s",
      token,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isPhoneVerified: user.isPhoneVerified
      }
    });

  } catch (err) {
    console.error('‚ùå Erreur lors de l\'inscription:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üîë CONNEXION √âTAPE 1 - V√âRIFIER IDENTIFIANTS ET ENVOYER OTP
// ====================
exports.initiateLogin = async (req, res) => {
  try {
    const { identifier, password } = req.body;

    if (!identifier || !password) {
      return res.status(400).json({ error: "Identifiant et mot de passe requis" });
    }

    // Rechercher par email ou t√©l√©phone
    const user = await User.findOne({
      where: {
        [Op.or]: [
          { email: identifier },
          { phone: identifier }
        ]
      }
    });

    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    // V√©rifier le mot de passe
    const isMatch = await bcrypt.compare(password, user.passwordHash);
    if (!isMatch) {
      return res.status(401).json({ error: "Mot de passe incorrect" });
    }

    // Si l'utilisateur a un t√©l√©phone, envoyer un OTP
    if (user.phone) {
      // üîß POINT D'INT√âGRATION SMS - ENVOYER OTP DE CONNEXION
      console.log('üì± Envoi OTP de connexion pour:', user.phone);
      const otpResult = await smsService.sendOTP(user.phone, 'login');

      if (!otpResult.success) {
        // Si l'envoi OTP √©choue, permettre la connexion directe
        console.warn('‚ö†Ô∏è √âchec envoi OTP, connexion directe autoris√©e');
        const token = generateToken(user);
        
        return res.json({
          success: true,
          requiresOTP: false,
          message: "Connexion r√©ussie (OTP non disponible)",
          token,
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            phone: user.phone,
            role: user.role
          }
        });
      }

      // OTP envoy√© avec succ√®s
      res.json({
        success: true,
        requiresOTP: true,
        message: "Code de v√©rification envoy√© par SMS",
        userId: user.id,
        phoneNumber: user.phone,
        expiresIn: otpResult.expiresIn
      });

    } else {
      // Pas de t√©l√©phone, connexion directe
      const token = generateToken(user);
      
      res.json({
        success: true,
        requiresOTP: false,
        message: "Connexion r√©ussie",
        token,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          phone: user.phone,
          role: user.role
        }
      });
    }

  } catch (err) {
    console.error('‚ùå Erreur lors de l\'initiation de connexion:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üîë CONNEXION √âTAPE 2 - V√âRIFIER OTP ET FINALISER CONNEXION
// ====================
exports.login = async (req, res) => {
  try {
    const { userId, otpCode } = req.body;

    if (!userId || !otpCode) {
      return res.status(400).json({ error: "ID utilisateur et code OTP requis" });
    }

    // R√©cup√©rer l'utilisateur
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    // üîß POINT D'INT√âGRATION SMS - V√âRIFIER OTP DE CONNEXION
    console.log('‚úÖ V√©rification OTP de connexion pour:', user.phone);
    const otpVerification = await smsService.verifyOTP(user.phone, otpCode, 'login');

    if (!otpVerification.success) {
      return res.status(400).json({
        error: otpVerification.error,
        code: otpVerification.code,
        attemptsLeft: otpVerification.attemptsLeft
      });
    }

    // Mettre √† jour la derni√®re connexion
    user.lastLogin = new Date();
    await user.save();

    // G√©n√©rer un token
    const token = generateToken(user);

    console.log('‚úÖ Connexion r√©ussie pour:', user.id);

    res.json({
      success: true,
      message: "Connexion r√©ussie",
      token,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role,
        isPhoneVerified: user.isPhoneVerified
      }
    });

  } catch (err) {
    console.error('‚ùå Erreur lors de la connexion:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üîÑ RENVOYER UN CODE OTP
// ====================
exports.resendOTP = async (req, res) => {
  try {
    const { phoneNumber, purpose = 'login' } = req.body;

    if (!phoneNumber) {
      return res.status(400).json({ error: "Num√©ro de t√©l√©phone requis" });
    }

    // üîß POINT D'INT√âGRATION SMS - RENVOYER OTP
    console.log('üîÑ Renvoi OTP pour:', phoneNumber, purpose);
    const otpResult = await smsService.resendOTP(phoneNumber, purpose);

    if (!otpResult.success) {
      return res.status(500).json({
        error: "Erreur lors du renvoi du code",
        details: otpResult.error
      });
    }

    res.json({
      success: true,
      message: "Nouveau code envoy√© par SMS",
      phoneNumber: phoneNumber,
      expiresIn: otpResult.expiresIn
    });

  } catch (err) {
    console.error('‚ùå Erreur lors du renvoi OTP:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üîê R√âINITIALISATION DE MOT DE PASSE AVEC OTP
// ====================
exports.requestPasswordReset = async (req, res) => {
  try {
    const { identifier } = req.body; // email ou t√©l√©phone

    if (!identifier) {
      return res.status(400).json({ error: "Email ou t√©l√©phone requis" });
    }

    // Rechercher l'utilisateur
    const user = await User.findOne({
      where: {
        [Op.or]: [
          { email: identifier },
          { phone: identifier }
        ]
      }
    });

    if (!user) {
      // Ne pas r√©v√©ler si l'utilisateur existe ou non
      return res.json({
        success: true,
        message: "Si ce compte existe, un code de r√©initialisation a √©t√© envoy√©"
      });
    }

    // Si l'utilisateur a un t√©l√©phone, envoyer OTP
    if (user.phone) {
      // üîß POINT D'INT√âGRATION SMS - ENVOYER OTP DE R√âINITIALISATION
      console.log('üì± Envoi OTP de r√©initialisation pour:', user.phone);
      const otpResult = await smsService.sendOTP(user.phone, 'password_reset');

      if (otpResult.success) {
        res.json({
          success: true,
          message: "Code de r√©initialisation envoy√© par SMS",
          phoneNumber: user.phone,
          expiresIn: otpResult.expiresIn
        });
      } else {
        res.status(500).json({
          error: "Erreur lors de l'envoi du code de r√©initialisation"
        });
      }
    } else {
      res.json({
        success: true,
        message: "Si ce compte existe, un code de r√©initialisation a √©t√© envoy√©"
      });
    }

  } catch (err) {
    console.error('‚ùå Erreur lors de la demande de r√©initialisation:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üîê CONFIRMER LA R√âINITIALISATION DE MOT DE PASSE
// ====================
exports.resetPassword = async (req, res) => {
  try {
    const { phoneNumber, otpCode, newPassword } = req.body;

    if (!phoneNumber || !otpCode || !newPassword) {
      return res.status(400).json({
        error: "T√©l√©phone, code OTP et nouveau mot de passe requis"
      });
    }

    // üîß POINT D'INT√âGRATION SMS - V√âRIFIER OTP DE R√âINITIALISATION
    console.log('‚úÖ V√©rification OTP de r√©initialisation pour:', phoneNumber);
    const otpVerification = await smsService.verifyOTP(phoneNumber, otpCode, 'password_reset');

    if (!otpVerification.success) {
      return res.status(400).json({
        error: otpVerification.error,
        code: otpVerification.code,
        attemptsLeft: otpVerification.attemptsLeft
      });
    }

    // Trouver l'utilisateur
    const user = await User.findOne({ where: { phone: phoneNumber } });
    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    // Hasher le nouveau mot de passe
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Mettre √† jour le mot de passe
    user.passwordHash = hashedPassword;
    user.passwordResetAt = new Date();
    await user.save();

    console.log('‚úÖ Mot de passe r√©initialis√© pour:', user.id);

    res.json({
      success: true,
      message: "Mot de passe r√©initialis√© avec succ√®s"
    });

  } catch (err) {
    console.error('‚ùå Erreur lors de la r√©initialisation:', err);
    res.status(500).json({ error: err.message });
  }
};

// ====================
// üë§ Profil utilisateur connect√©
// ====================
exports.me = async (req, res) => {
  try {
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['passwordHash'] }
    });

    res.json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
